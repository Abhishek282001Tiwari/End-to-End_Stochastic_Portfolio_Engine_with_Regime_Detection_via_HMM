name: Automated Backup and Recovery

on:
  schedule:
    # Daily backup at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      backup_type:
        description: 'Type of backup to perform'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - content_only
          - config_only
      retention_days:
        description: 'Days to retain backup'
        required: false
        default: '30'

jobs:
  create-backup:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for complete backup
          
      - name: Setup backup metadata
        id: backup-meta
        run: |
          echo "backup_date=$(date -u +%Y%m%d-%H%M%S)" >> $GITHUB_OUTPUT
          echo "backup_type=${{ github.event.inputs.backup_type || 'full' }}" >> $GITHUB_OUTPUT
          echo "retention_days=${{ github.event.inputs.retention_days || '30' }}" >> $GITHUB_OUTPUT
          echo "backup_branch=backup-$(date -u +%Y%m%d)" >> $GITHUB_OUTPUT
          
      - name: Create full backup
        if: steps.backup-meta.outputs.backup_type == 'full'
        run: |
          # Create comprehensive backup archive
          tar -czf backup-full-${{ steps.backup-meta.outputs.backup_date }}.tar.gz \
            --exclude='.git' \
            --exclude='_site' \
            --exclude='node_modules' \
            --exclude='.sass-cache' \
            --exclude='.jekyll-cache' \
            .
            
          # Create backup manifest
          cat > backup-manifest-${{ steps.backup-meta.outputs.backup_date }}.json << EOF
          {
            "backup_type": "full",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit_sha": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "repository": "${{ github.repository }}",
            "backup_size": "$(du -h backup-full-${{ steps.backup-meta.outputs.backup_date }}.tar.gz | cut -f1)",
            "files_included": [
              "source_code",
              "content",
              "assets",
              "configuration",
              "workflows"
            ],
            "restore_instructions": "Extract archive and restore using git or deployment pipeline"
          }
          EOF
          
      - name: Create content-only backup
        if: steps.backup-meta.outputs.backup_type == 'content_only'
        run: |
          # Backup only content files
          tar -czf backup-content-${{ steps.backup-meta.outputs.backup_date }}.tar.gz \
            *.md \
            _posts/ \
            _documentation/ \
            _research/ \
            _data/ \
            assets/img/ \
            assets/documents/
            
          # Create content manifest
          cat > backup-manifest-${{ steps.backup-meta.outputs.backup_date }}.json << EOF
          {
            "backup_type": "content_only",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit_sha": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "files_included": [
              "markdown_content",
              "research_papers",
              "documentation",
              "data_files",
              "images",
              "documents"
            ]
          }
          EOF
          
      - name: Create configuration backup
        if: steps.backup-meta.outputs.backup_type == 'config_only'
        run: |
          # Backup only configuration files
          tar -czf backup-config-${{ steps.backup-meta.outputs.backup_date }}.tar.gz \
            _config.yml \
            Gemfile \
            package.json \
            .github/ \
            _includes/ \
            _layouts/ \
            _sass/
            
          # Create config manifest
          cat > backup-manifest-${{ steps.backup-meta.outputs.backup_date }}.json << EOF
          {
            "backup_type": "config_only",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "commit_sha": "${{ github.sha }}",
            "branch": "${{ github.ref_name }}",
            "files_included": [
              "jekyll_config",
              "dependencies",
              "workflows",
              "templates",
              "styles"
            ]
          }
          EOF
          
      - name: Upload backup artifacts
        uses: actions/upload-artifact@v3
        with:
          name: backup-${{ steps.backup-meta.outputs.backup_type }}-${{ steps.backup-meta.outputs.backup_date }}
          path: |
            backup-*.tar.gz
            backup-manifest-*.json
          retention-days: ${{ fromJson(steps.backup-meta.outputs.retention_days) }}
          
      - name: Create backup branch
        if: steps.backup-meta.outputs.backup_type == 'full'
        run: |
          # Create backup branch with current state
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action Backup"
          git checkout -b ${{ steps.backup-meta.outputs.backup_branch }}
          
          # Add backup metadata
          echo "# Backup Branch - ${{ steps.backup-meta.outputs.backup_date }}" > BACKUP_INFO.md
          echo "" >> BACKUP_INFO.md
          echo "**Backup Date:** $(date -u)" >> BACKUP_INFO.md
          echo "**Source Commit:** ${{ github.sha }}" >> BACKUP_INFO.md
          echo "**Source Branch:** ${{ github.ref_name }}" >> BACKUP_INFO.md
          echo "**Backup Type:** ${{ steps.backup-meta.outputs.backup_type }}" >> BACKUP_INFO.md
          echo "" >> BACKUP_INFO.md
          echo "## Restore Instructions" >> BACKUP_INFO.md
          echo "1. Checkout this branch: \`git checkout ${{ steps.backup-meta.outputs.backup_branch }}\`" >> BACKUP_INFO.md
          echo "2. Merge or cherry-pick changes as needed" >> BACKUP_INFO.md
          echo "3. Run deployment pipeline to restore site" >> BACKUP_INFO.md
          
          git add BACKUP_INFO.md
          git commit -m "Automated backup: ${{ steps.backup-meta.outputs.backup_date }}"
          git push origin ${{ steps.backup-meta.outputs.backup_branch }}
          
      - name: Cleanup old backups
        run: |
          # Clean up old backup artifacts (handled by retention-days)
          echo "Backup cleanup handled by artifact retention policy"
          
          # List recent backups for reference
          echo "Recent backup artifacts:"
          echo "- backup-${{ steps.backup-meta.outputs.backup_type }}-${{ steps.backup-meta.outputs.backup_date }}"

  test-backup-integrity:
    runs-on: ubuntu-latest
    needs: create-backup
    
    steps:
      - name: Download backup artifact
        uses: actions/download-artifact@v3
        with:
          name: backup-${{ needs.create-backup.outputs.backup_type || 'full' }}-${{ needs.create-backup.outputs.backup_date }}
          
      - name: Verify backup integrity
        run: |
          # Test backup file integrity
          for backup_file in backup-*.tar.gz; do
            if [ -f "$backup_file" ]; then
              echo "Testing integrity of $backup_file"
              
              # Test archive integrity
              if tar -tzf "$backup_file" > /dev/null; then
                echo "âœ… Archive integrity check passed for $backup_file"
              else
                echo "âŒ Archive integrity check failed for $backup_file"
                exit 1
              fi
              
              # Check archive size
              size=$(du -h "$backup_file" | cut -f1)
              echo "ğŸ“¦ Backup size: $size"
              
              # List contents
              echo "ğŸ“‹ Archive contents:"
              tar -tzf "$backup_file" | head -20
              echo "..."
            fi
          done
          
      - name: Validate backup manifest
        run: |
          for manifest_file in backup-manifest-*.json; do
            if [ -f "$manifest_file" ]; then
              echo "Validating manifest: $manifest_file"
              
              # Validate JSON syntax
              if python3 -m json.tool "$manifest_file" > /dev/null; then
                echo "âœ… Manifest JSON is valid"
              else
                echo "âŒ Manifest JSON is invalid"
                exit 1
              fi
              
              # Display manifest contents
              echo "ğŸ“„ Manifest contents:"
              cat "$manifest_file" | python3 -m json.tool
            fi
          done

  disaster-recovery-test:
    runs-on: ubuntu-latest
    needs: [create-backup, test-backup-integrity]
    if: github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Download backup artifact
        uses: actions/download-artifact@v3
        with:
          name: backup-${{ needs.create-backup.outputs.backup_type || 'full' }}-${{ needs.create-backup.outputs.backup_date }}
          
      - name: Simulate disaster recovery
        run: |
          echo "ğŸš¨ Simulating disaster recovery scenario"
          
          # Extract backup
          for backup_file in backup-*.tar.gz; do
            if [ -f "$backup_file" ]; then
              echo "Extracting backup: $backup_file"
              mkdir -p recovery-test
              tar -xzf "$backup_file" -C recovery-test
              
              # Verify critical files exist
              critical_files=(
                "_config.yml"
                "index.md"
                "Gemfile"
                "_layouts/default.html"
              )
              
              for file in "${critical_files[@]}"; do
                if [ -f "recovery-test/$file" ]; then
                  echo "âœ… Critical file found: $file"
                else
                  echo "âŒ Critical file missing: $file"
                  exit 1
                fi
              done
              
              echo "âœ… Disaster recovery test passed"
            fi
          done
          
      - name: Test Jekyll build from backup
        run: |
          cd recovery-test
          
          # Install Ruby and dependencies
          sudo apt-get update
          sudo apt-get install -y ruby-full build-essential zlib1g-dev
          
          # Install bundler
          gem install bundler
          
          # Install dependencies (if Gemfile exists)
          if [ -f "Gemfile" ]; then
            bundle install
            
            # Test Jekyll build
            echo "Testing Jekyll build from backup..."
            bundle exec jekyll build --destination _site_test
            
            if [ -d "_site_test" ] && [ -f "_site_test/index.html" ]; then
              echo "âœ… Jekyll build successful from backup"
            else
              echo "âŒ Jekyll build failed from backup"
              exit 1
            fi
          else
            echo "âš ï¸  No Gemfile found, skipping Jekyll build test"
          fi

  backup-notification:
    runs-on: ubuntu-latest
    needs: [create-backup, test-backup-integrity]
    if: always()
    
    steps:
      - name: Send backup notification
        run: |
          if [ "${{ needs.create-backup.result }}" == "success" ] && [ "${{ needs.test-backup-integrity.result }}" == "success" ]; then
            echo "âœ… Backup completed successfully"
            echo "ğŸ“¦ Backup type: ${{ needs.create-backup.outputs.backup_type || 'full' }}"
            echo "ğŸ“… Backup date: ${{ needs.create-backup.outputs.backup_date }}"
            echo "ğŸ”„ Retention: ${{ needs.create-backup.outputs.retention_days || '30' }} days"
          else
            echo "âŒ Backup failed or encountered issues"
            echo "ğŸ” Check logs for details"
            exit 1
          fi